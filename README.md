# Rust bindings to the SDK and app

## Installation

You will need to add a toolchain to your Rust installation :

`rustup target add thumbv6m-none-eabi`

Next, install `bindgen`

`cargo install bindgen`

## Generating the bindings 

Pregenerated bindings to the sdk located in `nanosdk_1.6` were already generated for this project.

If you want to use another SDK, they can be generated by copy-pasting `wrapper.h` in the root of this directory to the root of the SDK, and then using the following command :

`TARGET=thumbv6m-none-eabi bindgen wrapper.h --use-core --no-prepend-enum-name --no-doc-comments --with-derive-default --no-derive-debug --ctypes-prefix=cty -- -fshort-enums -Ilib_ux/include -I. > bindings.rs`

Then, copy `bindings.rs` into the `src` folder of this project.

Note that `wrapper.h` contains flag definitions that might not match with your expected app configuration. You can change those before generating the bindings.

## Building

You can build on either Windows or Linux with a simple `cargo build` or `cargo build --release`

If you want to use a specific SDK, use:
`export BOLOS_SDK=/path/to/sdk/; cargo build`

By default, `nanosdk_1.6` will be used if `BOLOS_SDK` is not specified.

## Testing

One can for example use [speculos](https://github.com/LedgerHQ/speculos)

`python speculos.py ./target/thumbv6m-none-eabi/release/rust-app-demo -k 1.6`

On a real device, you can use the loading script `load.py`.

There is a small test script that sends some of the available commands in `test/test_cmds.py`

## What's next

The goal would be to reduce the C part as much as possible, and make every feature of the C SDK easily available in Rust. This means taking care of some macros that are not exported in the bindings.

There are some parts that could be simplified in `build.rs` also.