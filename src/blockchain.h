// Generated by Molecule 0.5.0

#define MOLECULEC_VERSION        5000
#define MOLECULE_API_VERSION_MIN 5000

#include "molecule_reader.h"

#ifndef BLOCKCHAIN_H
#define BLOCKCHAIN_H

#ifdef __cplusplus
#define _CPP_BEGIN extern "C" {
#define _CPP_END   }
_CPP_BEGIN
#endif /* __cplusplus */

#ifndef MOLECULE_API_DECORATOR
#define __DEFINE_MOLECULE_API_DECORATOR_BLOCKCHAIN
#define MOLECULE_API_DECORATOR
#endif /* MOLECULE_API_DECORATOR */

/*
 * Reader APIs
 */

#define MolReader_Uint32_verify(s, c)  mol_verify_fixed_size(s, 4)
#define MolReader_Uint32_get_nth0(s)   mol_slice_by_offset(s, 0, 1)
#define MolReader_Uint32_get_nth1(s)   mol_slice_by_offset(s, 1, 1)
#define MolReader_Uint32_get_nth2(s)   mol_slice_by_offset(s, 2, 1)
#define MolReader_Uint32_get_nth3(s)   mol_slice_by_offset(s, 3, 1)
#define MolReader_Uint64_verify(s, c)  mol_verify_fixed_size(s, 8)
#define MolReader_Uint64_get_nth0(s)   mol_slice_by_offset(s, 0, 1)
#define MolReader_Uint64_get_nth1(s)   mol_slice_by_offset(s, 1, 1)
#define MolReader_Uint64_get_nth2(s)   mol_slice_by_offset(s, 2, 1)
#define MolReader_Uint64_get_nth3(s)   mol_slice_by_offset(s, 3, 1)
#define MolReader_Uint64_get_nth4(s)   mol_slice_by_offset(s, 4, 1)
#define MolReader_Uint64_get_nth5(s)   mol_slice_by_offset(s, 5, 1)
#define MolReader_Uint64_get_nth6(s)   mol_slice_by_offset(s, 6, 1)
#define MolReader_Uint64_get_nth7(s)   mol_slice_by_offset(s, 7, 1)
#define MolReader_Uint128_verify(s, c) mol_verify_fixed_size(s, 16)
#define MolReader_Uint128_get_nth0(s)  mol_slice_by_offset(s, 0, 1)
#define MolReader_Uint128_get_nth1(s)  mol_slice_by_offset(s, 1, 1)
#define MolReader_Uint128_get_nth2(s)  mol_slice_by_offset(s, 2, 1)
#define MolReader_Uint128_get_nth3(s)  mol_slice_by_offset(s, 3, 1)
#define MolReader_Uint128_get_nth4(s)  mol_slice_by_offset(s, 4, 1)
#define MolReader_Uint128_get_nth5(s)  mol_slice_by_offset(s, 5, 1)
#define MolReader_Uint128_get_nth6(s)  mol_slice_by_offset(s, 6, 1)
#define MolReader_Uint128_get_nth7(s)  mol_slice_by_offset(s, 7, 1)
#define MolReader_Uint128_get_nth8(s)  mol_slice_by_offset(s, 8, 1)
#define MolReader_Uint128_get_nth9(s)  mol_slice_by_offset(s, 9, 1)
#define MolReader_Uint128_get_nth10(s) mol_slice_by_offset(s, 10, 1)
#define MolReader_Uint128_get_nth11(s) mol_slice_by_offset(s, 11, 1)
#define MolReader_Uint128_get_nth12(s) mol_slice_by_offset(s, 12, 1)
#define MolReader_Uint128_get_nth13(s) mol_slice_by_offset(s, 13, 1)
#define MolReader_Uint128_get_nth14(s) mol_slice_by_offset(s, 14, 1)
#define MolReader_Uint128_get_nth15(s) mol_slice_by_offset(s, 15, 1)
#define MolReader_Byte32_verify(s, c)  mol_verify_fixed_size(s, 32)
#define MolReader_Byte32_get_nth0(s)   mol_slice_by_offset(s, 0, 1)
#define MolReader_Byte32_get_nth1(s)   mol_slice_by_offset(s, 1, 1)
#define MolReader_Byte32_get_nth2(s)   mol_slice_by_offset(s, 2, 1)
#define MolReader_Byte32_get_nth3(s)   mol_slice_by_offset(s, 3, 1)
#define MolReader_Byte32_get_nth4(s)   mol_slice_by_offset(s, 4, 1)
#define MolReader_Byte32_get_nth5(s)   mol_slice_by_offset(s, 5, 1)
#define MolReader_Byte32_get_nth6(s)   mol_slice_by_offset(s, 6, 1)
#define MolReader_Byte32_get_nth7(s)   mol_slice_by_offset(s, 7, 1)
#define MolReader_Byte32_get_nth8(s)   mol_slice_by_offset(s, 8, 1)
#define MolReader_Byte32_get_nth9(s)   mol_slice_by_offset(s, 9, 1)
#define MolReader_Byte32_get_nth10(s)  mol_slice_by_offset(s, 10, 1)
#define MolReader_Byte32_get_nth11(s)  mol_slice_by_offset(s, 11, 1)
#define MolReader_Byte32_get_nth12(s)  mol_slice_by_offset(s, 12, 1)
#define MolReader_Byte32_get_nth13(s)  mol_slice_by_offset(s, 13, 1)
#define MolReader_Byte32_get_nth14(s)  mol_slice_by_offset(s, 14, 1)
#define MolReader_Byte32_get_nth15(s)  mol_slice_by_offset(s, 15, 1)
#define MolReader_Byte32_get_nth16(s)  mol_slice_by_offset(s, 16, 1)
#define MolReader_Byte32_get_nth17(s)  mol_slice_by_offset(s, 17, 1)
#define MolReader_Byte32_get_nth18(s)  mol_slice_by_offset(s, 18, 1)
#define MolReader_Byte32_get_nth19(s)  mol_slice_by_offset(s, 19, 1)
#define MolReader_Byte32_get_nth20(s)  mol_slice_by_offset(s, 20, 1)
#define MolReader_Byte32_get_nth21(s)  mol_slice_by_offset(s, 21, 1)
#define MolReader_Byte32_get_nth22(s)  mol_slice_by_offset(s, 22, 1)
#define MolReader_Byte32_get_nth23(s)  mol_slice_by_offset(s, 23, 1)
#define MolReader_Byte32_get_nth24(s)  mol_slice_by_offset(s, 24, 1)
#define MolReader_Byte32_get_nth25(s)  mol_slice_by_offset(s, 25, 1)
#define MolReader_Byte32_get_nth26(s)  mol_slice_by_offset(s, 26, 1)
#define MolReader_Byte32_get_nth27(s)  mol_slice_by_offset(s, 27, 1)
#define MolReader_Byte32_get_nth28(s)  mol_slice_by_offset(s, 28, 1)
#define MolReader_Byte32_get_nth29(s)  mol_slice_by_offset(s, 29, 1)
#define MolReader_Byte32_get_nth30(s)  mol_slice_by_offset(s, 30, 1)
#define MolReader_Byte32_get_nth31(s)  mol_slice_by_offset(s, 31, 1)
#define MolReader_Uint256_verify(s, c) mol_verify_fixed_size(s, 32)
#define MolReader_Uint256_get_nth0(s)  mol_slice_by_offset(s, 0, 1)
#define MolReader_Uint256_get_nth1(s)  mol_slice_by_offset(s, 1, 1)
#define MolReader_Uint256_get_nth2(s)  mol_slice_by_offset(s, 2, 1)
#define MolReader_Uint256_get_nth3(s)  mol_slice_by_offset(s, 3, 1)
#define MolReader_Uint256_get_nth4(s)  mol_slice_by_offset(s, 4, 1)
#define MolReader_Uint256_get_nth5(s)  mol_slice_by_offset(s, 5, 1)
#define MolReader_Uint256_get_nth6(s)  mol_slice_by_offset(s, 6, 1)
#define MolReader_Uint256_get_nth7(s)  mol_slice_by_offset(s, 7, 1)
#define MolReader_Uint256_get_nth8(s)  mol_slice_by_offset(s, 8, 1)
#define MolReader_Uint256_get_nth9(s)  mol_slice_by_offset(s, 9, 1)
#define MolReader_Uint256_get_nth10(s) mol_slice_by_offset(s, 10, 1)
#define MolReader_Uint256_get_nth11(s) mol_slice_by_offset(s, 11, 1)
#define MolReader_Uint256_get_nth12(s) mol_slice_by_offset(s, 12, 1)
#define MolReader_Uint256_get_nth13(s) mol_slice_by_offset(s, 13, 1)
#define MolReader_Uint256_get_nth14(s) mol_slice_by_offset(s, 14, 1)
#define MolReader_Uint256_get_nth15(s) mol_slice_by_offset(s, 15, 1)
#define MolReader_Uint256_get_nth16(s) mol_slice_by_offset(s, 16, 1)
#define MolReader_Uint256_get_nth17(s) mol_slice_by_offset(s, 17, 1)
#define MolReader_Uint256_get_nth18(s) mol_slice_by_offset(s, 18, 1)
#define MolReader_Uint256_get_nth19(s) mol_slice_by_offset(s, 19, 1)
#define MolReader_Uint256_get_nth20(s) mol_slice_by_offset(s, 20, 1)
#define MolReader_Uint256_get_nth21(s) mol_slice_by_offset(s, 21, 1)
#define MolReader_Uint256_get_nth22(s) mol_slice_by_offset(s, 22, 1)
#define MolReader_Uint256_get_nth23(s) mol_slice_by_offset(s, 23, 1)
#define MolReader_Uint256_get_nth24(s) mol_slice_by_offset(s, 24, 1)
#define MolReader_Uint256_get_nth25(s) mol_slice_by_offset(s, 25, 1)
#define MolReader_Uint256_get_nth26(s) mol_slice_by_offset(s, 26, 1)
#define MolReader_Uint256_get_nth27(s) mol_slice_by_offset(s, 27, 1)
#define MolReader_Uint256_get_nth28(s) mol_slice_by_offset(s, 28, 1)
#define MolReader_Uint256_get_nth29(s) mol_slice_by_offset(s, 29, 1)
#define MolReader_Uint256_get_nth30(s) mol_slice_by_offset(s, 30, 1)
#define MolReader_Uint256_get_nth31(s) mol_slice_by_offset(s, 31, 1)
#define MolReader_Bytes_verify(s, c)   mol_fixvec_verify(s, 1)
#define MolReader_Bytes_length(s)      mol_fixvec_length(s)
#define MolReader_Bytes_get(s, i)      mol_fixvec_slice_by_index(s, 1, i)
#define MolReader_Bytes_raw_bytes(s)   mol_fixvec_slice_raw_bytes(s)
MOLECULE_API_DECORATOR mol_errno MolReader_BytesOpt_verify(const mol_seg_t *, bool);
#define MolReader_BytesOpt_is_none(s) mol_option_is_none(s)
MOLECULE_API_DECORATOR mol_errno MolReader_BytesVec_verify(const mol_seg_t *, bool);
#define MolReader_BytesVec_length(s)     mol_dynvec_length(s)
#define MolReader_BytesVec_get(s, i)     mol_dynvec_slice_by_index(s, i)
#define MolReader_Byte32Vec_verify(s, c) mol_fixvec_verify(s, 32)
#define MolReader_Byte32Vec_length(s)    mol_fixvec_length(s)
#define MolReader_Byte32Vec_get(s, i)    mol_fixvec_slice_by_index(s, 32, i)
MOLECULE_API_DECORATOR mol_errno MolReader_ScriptOpt_verify(const mol_seg_t *, bool);
#define MolReader_ScriptOpt_is_none(s)         mol_option_is_none(s)
#define MolReader_ProposalShortId_verify(s, c) mol_verify_fixed_size(s, 10)
#define MolReader_ProposalShortId_get_nth0(s)  mol_slice_by_offset(s, 0, 1)
#define MolReader_ProposalShortId_get_nth1(s)  mol_slice_by_offset(s, 1, 1)
#define MolReader_ProposalShortId_get_nth2(s)  mol_slice_by_offset(s, 2, 1)
#define MolReader_ProposalShortId_get_nth3(s)  mol_slice_by_offset(s, 3, 1)
#define MolReader_ProposalShortId_get_nth4(s)  mol_slice_by_offset(s, 4, 1)
#define MolReader_ProposalShortId_get_nth5(s)  mol_slice_by_offset(s, 5, 1)
#define MolReader_ProposalShortId_get_nth6(s)  mol_slice_by_offset(s, 6, 1)
#define MolReader_ProposalShortId_get_nth7(s)  mol_slice_by_offset(s, 7, 1)
#define MolReader_ProposalShortId_get_nth8(s)  mol_slice_by_offset(s, 8, 1)
#define MolReader_ProposalShortId_get_nth9(s)  mol_slice_by_offset(s, 9, 1)
MOLECULE_API_DECORATOR mol_errno MolReader_UncleBlockVec_verify(const mol_seg_t *, bool);
#define MolReader_UncleBlockVec_length(s) mol_dynvec_length(s)
#define MolReader_UncleBlockVec_get(s, i) mol_dynvec_slice_by_index(s, i)
MOLECULE_API_DECORATOR mol_errno MolReader_TransactionVec_verify(const mol_seg_t *, bool);
#define MolReader_TransactionVec_length(s)        mol_dynvec_length(s)
#define MolReader_TransactionVec_get(s, i)        mol_dynvec_slice_by_index(s, i)
#define MolReader_ProposalShortIdVec_verify(s, c) mol_fixvec_verify(s, 10)
#define MolReader_ProposalShortIdVec_length(s)    mol_fixvec_length(s)
#define MolReader_ProposalShortIdVec_get(s, i)    mol_fixvec_slice_by_index(s, 10, i)
#define MolReader_CellDepVec_verify(s, c)         mol_fixvec_verify(s, 37)
#define MolReader_CellDepVec_length(s)            mol_fixvec_length(s)
#define MolReader_CellDepVec_get(s, i)            mol_fixvec_slice_by_index(s, 37, i)
#define MolReader_CellInputVec_verify(s, c)       mol_fixvec_verify(s, 44)
#define MolReader_CellInputVec_length(s)          mol_fixvec_length(s)
#define MolReader_CellInputVec_get(s, i)          mol_fixvec_slice_by_index(s, 44, i)
MOLECULE_API_DECORATOR mol_errno MolReader_CellOutputVec_verify(const mol_seg_t *, bool);
#define MolReader_CellOutputVec_length(s) mol_dynvec_length(s)
#define MolReader_CellOutputVec_get(s, i) mol_dynvec_slice_by_index(s, i)
MOLECULE_API_DECORATOR mol_errno MolReader_Script_verify(const mol_seg_t *, bool);
#define MolReader_Script_actual_field_count(s)     mol_table_actual_field_count(s)
#define MolReader_Script_has_extra_fields(s)       mol_table_has_extra_fields(s, 3)
#define MolReader_Script_get_code_hash(s)          mol_table_slice_by_index(s, 0)
#define MolReader_Script_get_hash_type(s)          mol_table_slice_by_index(s, 1)
#define MolReader_Script_get_args(s)               mol_table_slice_by_index(s, 2)
#define MolReader_OutPoint_verify(s, c)            mol_verify_fixed_size(s, 36)
#define MolReader_OutPoint_get_tx_hash(s)          mol_slice_by_offset(s, 0, 32)
#define MolReader_OutPoint_get_index(s)            mol_slice_by_offset(s, 32, 4)
#define MolReader_CellInput_verify(s, c)           mol_verify_fixed_size(s, 44)
#define MolReader_CellInput_get_since(s)           mol_slice_by_offset(s, 0, 8)
#define MolReader_CellInput_get_previous_output(s) mol_slice_by_offset(s, 8, 36)
MOLECULE_API_DECORATOR mol_errno MolReader_CellOutput_verify(const mol_seg_t *, bool);
#define MolReader_CellOutput_actual_field_count(s) mol_table_actual_field_count(s)
#define MolReader_CellOutput_has_extra_fields(s)   mol_table_has_extra_fields(s, 3)
#define MolReader_CellOutput_get_capacity(s)       mol_table_slice_by_index(s, 0)
#define MolReader_CellOutput_get_lock(s)           mol_table_slice_by_index(s, 1)
#define MolReader_CellOutput_get_type_(s)          mol_table_slice_by_index(s, 2)
#define MolReader_CellDep_verify(s, c)             mol_verify_fixed_size(s, 37)
#define MolReader_CellDep_get_out_point(s)         mol_slice_by_offset(s, 0, 36)
#define MolReader_CellDep_get_dep_type(s)          mol_slice_by_offset(s, 36, 1)
MOLECULE_API_DECORATOR mol_errno MolReader_RawTransaction_verify(const mol_seg_t *, bool);
#define MolReader_RawTransaction_actual_field_count(s) mol_table_actual_field_count(s)
#define MolReader_RawTransaction_has_extra_fields(s)   mol_table_has_extra_fields(s, 6)
#define MolReader_RawTransaction_get_version(s)        mol_table_slice_by_index(s, 0)
#define MolReader_RawTransaction_get_cell_deps(s)      mol_table_slice_by_index(s, 1)
#define MolReader_RawTransaction_get_header_deps(s)    mol_table_slice_by_index(s, 2)
#define MolReader_RawTransaction_get_inputs(s)         mol_table_slice_by_index(s, 3)
#define MolReader_RawTransaction_get_outputs(s)        mol_table_slice_by_index(s, 4)
#define MolReader_RawTransaction_get_outputs_data(s)   mol_table_slice_by_index(s, 5)
MOLECULE_API_DECORATOR mol_errno MolReader_Transaction_verify(const mol_seg_t *, bool);
#define MolReader_Transaction_actual_field_count(s)  mol_table_actual_field_count(s)
#define MolReader_Transaction_has_extra_fields(s)    mol_table_has_extra_fields(s, 2)
#define MolReader_Transaction_get_raw(s)             mol_table_slice_by_index(s, 0)
#define MolReader_Transaction_get_witnesses(s)       mol_table_slice_by_index(s, 1)
#define MolReader_RawHeader_verify(s, c)             mol_verify_fixed_size(s, 192)
#define MolReader_RawHeader_get_version(s)           mol_slice_by_offset(s, 0, 4)
#define MolReader_RawHeader_get_compact_target(s)    mol_slice_by_offset(s, 4, 4)
#define MolReader_RawHeader_get_timestamp(s)         mol_slice_by_offset(s, 8, 8)
#define MolReader_RawHeader_get_number(s)            mol_slice_by_offset(s, 16, 8)
#define MolReader_RawHeader_get_epoch(s)             mol_slice_by_offset(s, 24, 8)
#define MolReader_RawHeader_get_parent_hash(s)       mol_slice_by_offset(s, 32, 32)
#define MolReader_RawHeader_get_transactions_root(s) mol_slice_by_offset(s, 64, 32)
#define MolReader_RawHeader_get_proposals_hash(s)    mol_slice_by_offset(s, 96, 32)
#define MolReader_RawHeader_get_uncles_hash(s)       mol_slice_by_offset(s, 128, 32)
#define MolReader_RawHeader_get_dao(s)               mol_slice_by_offset(s, 160, 32)
#define MolReader_Header_verify(s, c)                mol_verify_fixed_size(s, 208)
#define MolReader_Header_get_raw(s)                  mol_slice_by_offset(s, 0, 192)
#define MolReader_Header_get_nonce(s)                mol_slice_by_offset(s, 192, 16)
MOLECULE_API_DECORATOR mol_errno MolReader_UncleBlock_verify(const mol_seg_t *, bool);
#define MolReader_UncleBlock_actual_field_count(s) mol_table_actual_field_count(s)
#define MolReader_UncleBlock_has_extra_fields(s)   mol_table_has_extra_fields(s, 2)
#define MolReader_UncleBlock_get_header(s)         mol_table_slice_by_index(s, 0)
#define MolReader_UncleBlock_get_proposals(s)      mol_table_slice_by_index(s, 1)
MOLECULE_API_DECORATOR mol_errno MolReader_Block_verify(const mol_seg_t *, bool);
#define MolReader_Block_actual_field_count(s) mol_table_actual_field_count(s)
#define MolReader_Block_has_extra_fields(s)   mol_table_has_extra_fields(s, 4)
#define MolReader_Block_get_header(s)         mol_table_slice_by_index(s, 0)
#define MolReader_Block_get_uncles(s)         mol_table_slice_by_index(s, 1)
#define MolReader_Block_get_transactions(s)   mol_table_slice_by_index(s, 2)
#define MolReader_Block_get_proposals(s)      mol_table_slice_by_index(s, 3)
MOLECULE_API_DECORATOR mol_errno MolReader_CellbaseWitness_verify(const mol_seg_t *, bool);
#define MolReader_CellbaseWitness_actual_field_count(s) mol_table_actual_field_count(s)
#define MolReader_CellbaseWitness_has_extra_fields(s)   mol_table_has_extra_fields(s, 2)
#define MolReader_CellbaseWitness_get_lock(s)           mol_table_slice_by_index(s, 0)
#define MolReader_CellbaseWitness_get_message(s)        mol_table_slice_by_index(s, 1)
MOLECULE_API_DECORATOR mol_errno MolReader_WitnessArgs_verify(const mol_seg_t *, bool);
#define MolReader_WitnessArgs_actual_field_count(s) mol_table_actual_field_count(s)
#define MolReader_WitnessArgs_has_extra_fields(s)   mol_table_has_extra_fields(s, 3)
#define MolReader_WitnessArgs_get_lock(s)           mol_table_slice_by_index(s, 0)
#define MolReader_WitnessArgs_get_input_type(s)     mol_table_slice_by_index(s, 1)
#define MolReader_WitnessArgs_get_output_type(s)    mol_table_slice_by_index(s, 2)

/*
 * Default Value
 */

#define ____ 0x00

MOLECULE_API_DECORATOR const uint8_t MolDefault_Uint32[4] = {____, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Uint64[8] = {
    ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Uint128[16] = {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Byte32[32] = {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Uint256[32] = {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Bytes[4] = {____, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_BytesOpt[0] = {};
MOLECULE_API_DECORATOR const uint8_t MolDefault_BytesVec[4] = {0x04, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Byte32Vec[4] = {____, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_ScriptOpt[0] = {};
MOLECULE_API_DECORATOR const uint8_t MolDefault_ProposalShortId[10] = {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_UncleBlockVec[4] = {0x04, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_TransactionVec[4] = {0x04, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_ProposalShortIdVec[4] = {____, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_CellDepVec[4] = {____, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_CellInputVec[4] = {____, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_CellOutputVec[4] = {0x04, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Script[53] = {
    0x35, ____, ____, ____, 0x10, ____, ____, ____, 0x30, ____, ____, ____, 0x31, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_OutPoint[36] = {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_CellInput[44] = {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_CellOutput[77] = {
    0x4d, ____, ____, ____, 0x10, ____, ____, ____, 0x18, ____, ____, ____, 0x4d, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, 0x35, ____, ____, ____, 0x10, ____, ____, ____,
    0x30, ____, ____, ____, 0x31, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_CellDep[37] = {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_RawTransaction[52] = {
    0x34, ____, ____, ____, 0x1c, ____, ____, ____, 0x20, ____, ____, ____, 0x24, ____, ____, ____, 0x28, ____,
    ____, ____, 0x2c, ____, ____, ____, 0x30, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, 0x04, ____, ____, ____, 0x04, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Transaction[68] = {
    0x44, ____, ____, ____, 0x0c, ____, ____, ____, 0x40, ____, ____, ____, 0x34, ____, ____, ____, 0x1c,
    ____, ____, ____, 0x20, ____, ____, ____, 0x24, ____, ____, ____, 0x28, ____, ____, ____, 0x2c, ____,
    ____, ____, 0x30, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, 0x04, ____, ____, ____, 0x04, ____, ____, ____, 0x04, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_RawHeader[192] = {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Header[208] = {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_UncleBlock[224] = {
    0xe0, ____, ____, ____, 0x0c, ____, ____, ____, 0xdc, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Block[240] = {
    0xf0, ____, ____, ____, 0x14, ____, ____, ____, 0xe4, ____, ____, ____, 0xe8, ____, ____, ____, 0xec, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    0x04, ____, ____, ____, 0x04, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_CellbaseWitness[69] = {
    0x45, ____, ____, ____, 0x0c, ____, ____, ____, 0x41, ____, ____, ____, 0x35, ____, ____, ____, 0x10, ____,
    ____, ____, 0x30, ____, ____, ____, 0x31, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_WitnessArgs[16] = {
    0x10, ____, ____, ____, 0x10, ____, ____, ____, 0x10, ____, ____, ____, 0x10, ____, ____, ____,
};

#undef ____

/*
 * Reader Functions
 */

MOLECULE_API_DECORATOR mol_errno MolReader_BytesOpt_verify(const mol_seg_t *input,
                                                           bool __attribute__((unused)) compatible) {
    if (input->size != 0) {
        return MolReader_Bytes_verify(input, compatible);
    } else {
        return MOL_OK;
    }
}
MOLECULE_API_DECORATOR mol_errno MolReader_BytesVec_verify(const mol_seg_t *input,
                                                           bool __attribute__((unused)) compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t item_count = offset / 4 - 1;
    if (input->size < MOL_NUM_T_SIZE * (item_count + 1)) {
        return MOL_ERR_HEADER;
    }
    mol_num_t end;
    for (mol_num_t i = 1; i < item_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        end = mol_unpack_number(ptr);
        if (offset > end) {
            return MOL_ERR_OFFSET;
        }
        mol_seg_t inner;
        inner.ptr = input->ptr + offset;
        inner.size = end - offset;
        mol_errno errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        offset = end;
    }
    if (offset > total_size) {
        return MOL_ERR_OFFSET;
    }
    mol_seg_t inner;
    inner.ptr = input->ptr + offset;
    inner.size = total_size - offset;
    return MolReader_Bytes_verify(&inner, compatible);
}
MOLECULE_API_DECORATOR mol_errno MolReader_ScriptOpt_verify(const mol_seg_t *input, bool compatible) {
    if (input->size != 0) {
        return MolReader_Script_verify(input, compatible);
    } else {
        return MOL_OK;
    }
}
MOLECULE_API_DECORATOR mol_errno MolReader_UncleBlockVec_verify(const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t item_count = offset / 4 - 1;
    if (input->size < MOL_NUM_T_SIZE * (item_count + 1)) {
        return MOL_ERR_HEADER;
    }
    mol_num_t end;
    for (mol_num_t i = 1; i < item_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        end = mol_unpack_number(ptr);
        if (offset > end) {
            return MOL_ERR_OFFSET;
        }
        mol_seg_t inner;
        inner.ptr = input->ptr + offset;
        inner.size = end - offset;
        mol_errno errno = MolReader_UncleBlock_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        offset = end;
    }
    if (offset > total_size) {
        return MOL_ERR_OFFSET;
    }
    mol_seg_t inner;
    inner.ptr = input->ptr + offset;
    inner.size = total_size - offset;
    return MolReader_UncleBlock_verify(&inner, compatible);
}
MOLECULE_API_DECORATOR mol_errno MolReader_TransactionVec_verify(const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t item_count = offset / 4 - 1;
    if (input->size < MOL_NUM_T_SIZE * (item_count + 1)) {
        return MOL_ERR_HEADER;
    }
    mol_num_t end;
    for (mol_num_t i = 1; i < item_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        end = mol_unpack_number(ptr);
        if (offset > end) {
            return MOL_ERR_OFFSET;
        }
        mol_seg_t inner;
        inner.ptr = input->ptr + offset;
        inner.size = end - offset;
        mol_errno errno = MolReader_Transaction_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        offset = end;
    }
    if (offset > total_size) {
        return MOL_ERR_OFFSET;
    }
    mol_seg_t inner;
    inner.ptr = input->ptr + offset;
    inner.size = total_size - offset;
    return MolReader_Transaction_verify(&inner, compatible);
}
MOLECULE_API_DECORATOR mol_errno MolReader_CellOutputVec_verify(const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t item_count = offset / 4 - 1;
    if (input->size < MOL_NUM_T_SIZE * (item_count + 1)) {
        return MOL_ERR_HEADER;
    }
    mol_num_t end;
    for (mol_num_t i = 1; i < item_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        end = mol_unpack_number(ptr);
        if (offset > end) {
            return MOL_ERR_OFFSET;
        }
        mol_seg_t inner;
        inner.ptr = input->ptr + offset;
        inner.size = end - offset;
        mol_errno errno = MolReader_CellOutput_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        offset = end;
    }
    if (offset > total_size) {
        return MOL_ERR_OFFSET;
    }
    mol_seg_t inner;
    inner.ptr = input->ptr + offset;
    inner.size = total_size - offset;
    return MolReader_CellOutput_verify(&inner, compatible);
}
MOLECULE_API_DECORATOR mol_errno MolReader_Script_verify(const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE * (field_count + 1)) {
        return MOL_ERR_HEADER;
    }
    if (field_count > 3)
        return MOL_ERR_FIELD_COUNT;
    mol_num_t offsets[4];
    offsets[0] = offset;
    for (mol_num_t i = 1; i < field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i - 1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count - 1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
    mol_seg_t inner;
    mol_errno errno;
    inner.ptr = input->ptr + offsets[0];
    inner.size = offsets[1] - offsets[0];
    errno = MolReader_Byte32_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    if (offsets[2] - offsets[1] != 1) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[2];
    inner.size = offsets[3] - offsets[2];
    errno = MolReader_Bytes_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_CellOutput_verify(const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE * (field_count + 1)) {
        return MOL_ERR_HEADER;
    }
    if (field_count > 3)
        return MOL_ERR_FIELD_COUNT;
    mol_num_t offsets[4];
    offsets[0] = offset;
    for (mol_num_t i = 1; i < field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i - 1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count - 1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
    mol_seg_t inner;
    mol_errno errno;
    inner.ptr = input->ptr + offsets[0];
    inner.size = offsets[1] - offsets[0];
    errno = MolReader_Uint64_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[1];
    inner.size = offsets[2] - offsets[1];
    errno = MolReader_Script_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[2];
    inner.size = offsets[3] - offsets[2];
    errno = MolReader_ScriptOpt_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_RawTransaction_verify(const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 6) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 6) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE * (field_count + 1)) {
        return MOL_ERR_HEADER;
    }
    if (field_count > 6)
        return MOL_ERR_FIELD_COUNT;
    mol_num_t offsets[7];
    offsets[0] = offset;
    for (mol_num_t i = 1; i < field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i - 1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count - 1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
    mol_seg_t inner;
    mol_errno errno;
    inner.ptr = input->ptr + offsets[0];
    inner.size = offsets[1] - offsets[0];
    errno = MolReader_Uint32_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[1];
    inner.size = offsets[2] - offsets[1];
    errno = MolReader_CellDepVec_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[2];
    inner.size = offsets[3] - offsets[2];
    errno = MolReader_Byte32Vec_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[3];
    inner.size = offsets[4] - offsets[3];
    errno = MolReader_CellInputVec_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[4];
    inner.size = offsets[5] - offsets[4];
    errno = MolReader_CellOutputVec_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[5];
    inner.size = offsets[6] - offsets[5];
    errno = MolReader_BytesVec_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_Transaction_verify(const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE * (field_count + 1)) {
        return MOL_ERR_HEADER;
    }
    if (field_count > 2)
        return MOL_ERR_FIELD_COUNT;
    mol_num_t offsets[3];
    offsets[0] = offset;
    for (mol_num_t i = 1; i < field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i - 1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count - 1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
    mol_seg_t inner;
    mol_errno errno;
    inner.ptr = input->ptr + offsets[0];
    inner.size = offsets[1] - offsets[0];
    errno = MolReader_RawTransaction_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[1];
    inner.size = offsets[2] - offsets[1];
    errno = MolReader_BytesVec_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_UncleBlock_verify(const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE * (field_count + 1)) {
        return MOL_ERR_HEADER;
    }
    if (field_count > 2)
        return MOL_ERR_FIELD_COUNT;
    mol_num_t offsets[3];
    offsets[0] = offset;
    for (mol_num_t i = 1; i < field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i - 1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count - 1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
    mol_seg_t inner;
    mol_errno errno;
    inner.ptr = input->ptr + offsets[0];
    inner.size = offsets[1] - offsets[0];
    errno = MolReader_Header_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[1];
    inner.size = offsets[2] - offsets[1];
    errno = MolReader_ProposalShortIdVec_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_Block_verify(const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 4) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 4) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE * (field_count + 1)) {
        return MOL_ERR_HEADER;
    }
    if (field_count > 4)
        return MOL_ERR_FIELD_COUNT;
    mol_num_t offsets[5];
    offsets[0] = offset;
    for (mol_num_t i = 1; i < field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i - 1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count - 1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
    mol_seg_t inner;
    mol_errno errno;
    inner.ptr = input->ptr + offsets[0];
    inner.size = offsets[1] - offsets[0];
    errno = MolReader_Header_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[1];
    inner.size = offsets[2] - offsets[1];
    errno = MolReader_UncleBlockVec_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[2];
    inner.size = offsets[3] - offsets[2];
    errno = MolReader_TransactionVec_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[3];
    inner.size = offsets[4] - offsets[3];
    errno = MolReader_ProposalShortIdVec_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_CellbaseWitness_verify(const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE * (field_count + 1)) {
        return MOL_ERR_HEADER;
    }
    if (field_count > 2)
        return MOL_ERR_FIELD_COUNT;
    mol_num_t offsets[3];
    offsets[0] = offset;
    for (mol_num_t i = 1; i < field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i - 1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count - 1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
    mol_seg_t inner;
    mol_errno errno;
    inner.ptr = input->ptr + offsets[0];
    inner.size = offsets[1] - offsets[0];
    errno = MolReader_Script_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[1];
    inner.size = offsets[2] - offsets[1];
    errno = MolReader_Bytes_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_WitnessArgs_verify(const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE * (field_count + 1)) {
        return MOL_ERR_HEADER;
    }
    if (field_count > 3)
        return MOL_ERR_FIELD_COUNT;
    mol_num_t offsets[4];
    offsets[0] = offset;
    for (mol_num_t i = 1; i < field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i - 1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count - 1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
    mol_seg_t inner;
    mol_errno errno;
    inner.ptr = input->ptr + offsets[0];
    inner.size = offsets[1] - offsets[0];
    errno = MolReader_BytesOpt_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[1];
    inner.size = offsets[2] - offsets[1];
    errno = MolReader_BytesOpt_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    inner.ptr = input->ptr + offsets[2];
    inner.size = offsets[3] - offsets[2];
    errno = MolReader_BytesOpt_verify(&inner, compatible);
    if (errno != MOL_OK) {
        return MOL_ERR_DATA;
    }
    return MOL_OK;
}

#ifdef __DEFINE_MOLECULE_API_DECORATOR_BLOCKCHAIN
#undef MOLECULE_API_DECORATOR
#undef __DEFINE_MOLECULE_API_DECORATOR_BLOCKCHAIN
#endif /* __DEFINE_MOLECULE_API_DECORATOR_BLOCKCHAIN */

#ifdef __cplusplus
_CPP_END
#undef _CPP_BEGIN
#undef _CPP_END
#endif /* __cplusplus */

#endif /* BLOCKCHAIN_H */
